\section{Проектирование системы}
\label{sec:Chapter4} \index{Chapter4}


\subsection{Расширение функционала LMS}
Проектируемая система подразумевает наличие пользовательского интерфейса в системе LMS.
Система LMS была запущена в МФТИ весной 2020 года для обеспечения процесса дистанционного обучения.
Она построена на базе образовательной платформы с открытым исходным кодом Moodle.
За счет модульной архитектуры Moodle позволяет расширять свой функционал с помощью реализации сторонних плагинов.
Реализация плагина подразумевает разработку программного кода на скриптовом языке PHP.
Плагины в Moodle делятся на определенные типы, каждый из которых направлен на изменение или расширение стандартного поведения системы в определенной области. 
Судя по документации \cite{moodleDoc} на данный момент в последней версии системы поддерживается несколько десятков типов плагинов. 
Среди них есть и те, которые позволяют расширить интерфейс сдачи задания на проверку.

С помощью такого плагина можно переопределить логику, по которой происходит проверка задания.
Тестирование программы может занять длительное время, может накопиться очередь тестирования из-за ограниченности ресурсов проверяющей системы.
Поэтому плагин должен взаимодействовать с проверяющей системой в асинхронном режиме.
Самым простым решением будет разработать REST API, который будет иметь два метода.
Первый - POST метод для отправки решения и информации о задаче, которую студент решает.
Второй - GET метод для получения текущего статуса проверки и информации об оценке.
Когда студент отправляет свое решение на проверку, плагин будет вызывать POST метод, передавая решение студента и информацию о решаемой задаче.
Затем периодически асинхронно обновлять статус проверки с использованием GET метода.



\subsection{Способы програмного взаимодействия с Ejudge}
Одним из способов проверки решений в проектируемой системе должна стать проверка посредством Ejudge.
Для этого необходимо понять, какие существуют способы программного взаимодействия с ней.
Архитектурно Ejudge состоит из серверного ПО, а также набора CGI скриптов, которые предлагается установить на заранее подготовленный web сервер. 
CGI скрипты обеспечивают наличие удобного интерактивного пользовательского вэб интерфейса. 
Им могут пользоваться преподаватели, студенты и администраторы. 
Однако для программного взаимодействия с Ejudge будет проще в обход сайта взаимодействовать с сервером напрямую.

Действия, доступные пользователям в вэб интерфейсе, можно осуществлять напрямую через интерфейс командной строки, что дает возможность для программного взаимодействия с системой.
Доступ к серверу турниров из командной строки осуществляется через консольную утилиту.
Если система устанавливалась в соотвествии с официальной документацией \cite{ejudgeInstallationDoc}, 
то абсолютный путь к бинарному файлу утилиты - \path{"/opt/ejudge/bin/ejudge-contests-cmd"}.

\noindentОсновные варианты использования:

\noindent Напечатать версию системы ejudge и время компиляции системы:
\shellcmd{ejudge-contests-cmd --version} 

\noindent Напечатать краткую подсказку об использовании программы
\shellcmd{ejudge-contests-cmd --help} 

\noindent Для отправки решения на проверку используется команда
    
\shellcmd{ejudge-contests-cmd <contest\_id> submit-run <session\_file> <problem\_name> \newline <lang> <submission\_file\_path>}

\noindent Аргументы, которые необходимо передать:
\begin{itemize}
    \item contest\_id - id контеста, которому принадлежит проверяемая задача
    \item session\_file - файл авторизации
    \item problem\_name - имя задачи в рамках контеста
    \item lang - язык программирования, на котором написано проверяемое решение
    \item  submission\_file\_path - путь к файлу с решением
\end{itemize}
    
\noindent При успешной отправке на проверку команда вернет submit\_id - внутренний идентификатор отправки, с помощью которого можно отслеживать ее резлуьтат.

\noindent Для отслеживания статуса проверки:

\shellcmd{ejudge-contests-cmd <contest\_id> run-status <session\_file> <submit\_id>}

\noindent Для получения полного отчета о проверке:

\shellcmd{ejudge-contests-cmd <contest\_id> dump-report <session\_file> <submit\_id>}



\subsection{Архитектура}

При проектировании архитектуры любой системы надо опираться на основные требования, которые к ней предъявляются. 
Для интеграции с LMS система должна иметь REST API с двумя методами для отправки решения на проверку и получения актуального статуса проверки.
Должно быть реализовано несколько методов проверки решений, а также должна быть возможность добавить новый метод проверки без изменения имеющихся.
Первыми двумя механизмами проверки должны стать проверка посредством Ejudge и проверка MPI задач.

Проверка задач может занимать длительное время, поэтому взаимодействие пользователя с системой должно быть асинхронным.
Во время проведения контестов или контрольных работ ожидается рост числа запросов на проверку.
Система должна быть устойчива к этому и не переставать обрабатывать запросы пользователей при их растущем числе. 
Должна быть возможность горизонтально масштабировать систему при необходимости.
Также пользователям на постоянной основе должна быть доступна история отправок и результатов проверок.
Целостность и долговечность этой информации не должна зависеть от сбоев системы.
Все вышесказанное можеть быть достигнуто с помощью следующей архитектурной схемы (рис. \ref{fig:design}) .

Рассмотрим ее более подробно. 
Внутрь системы LMS интегрируется плагин, который расширяет интерфейс сдачи задания и добавляет возможность отправлять программу на проверку в проектируемую систему. 
Для отправки он использует POST метод \codebox{/submit}.
В теле запроса передается информация о проверяемой задаче, а также решение студента.
В ответ на отправку решения клиент получает уникальный идентификатор посылки.
Далее плагин может получить актуальный статус проверки с использованием GET метода \codebox{/submission\_status}, 
передавая в качестве аргумента полученный ранее идентификатор.

<<Сердцем>> системы является сервис координатор (блок coordinator рис. \ref{fig:design}). 
Именно он предоставляет публичный REST API интерфейс, который будет использоваться LMS плагином.
Помимо этого координатор отвечает за хранение истории проверок.
Состояние проверок должно быть согласованным и долговечным. 
Для этого сервис должен использовать реляционную базу данных, обладующую свойствами ACID.
На каждую новую посылку в таблице должна создаваться новая запись, соотвествующая этой проверке.
При этом должен использоваться тот же идентификатор, который ранее получил клиент, отправивший решение на проверку.
В дальнейшем при получении результата проверки кооридантор должен обновлять статус в таблице.

Также координатор хранит информацию о задачах и тестовых сценариях, которые необходимы для вынесения вердикта.
Это может быть набор тестовых сценариев, ожидаемые выходные данные программы, флаги компиляции, ограничения по времени и используемой памяти.

Полученное на проверку решение координатор должен отправить в проверяющий модуль, соотвествующий задаче (блок workers рис. \ref{fig:design}). 
Он мог бы отправлять решение напрямую в сервис проверки через REST API, однако при таком подходе добавление нового способа проверки потребует изменений в коде координатора.
Нужно будет добавлять ветку кода, связанную с отправкой решения в новый сервис провеки.
Также стоит отметить, что между координатором и сервисами проверки должно быть асинхронное взаимодействие, так как проверка задач может занимать существенное время.
Если делать это взаимодействие синхронным, то придется долгое время держать отдельное открытое tcp соединение на каждую задачу.
Такой подход совершенно не масштабируется.

Альтернативой мог бы стать подход с двумя методами: 
один для отправки на проверку, другой для получения актуального статуса. 
Однако в таком случае сервисы проверки должны были бы хранить состояние с информацией о посылках.
Поэтому наиболее правильным решением в данной ситуации будет использование брокера сообщений и событийно ориентированный подход.
Получив решение на проверку, координатор обогощает его информацией о задаче, формирует архив и отправляет его в очередь посылок (блок submission queue рис. \ref{fig:design}). 
С другого конца очереди на обновления подписываются сервисы проверки.
На основе заголовков сообщения, которые проставляет координатор, можно установить, какому сервису проверки сообщение предназачается.
Говоря иными словами, на основе заголовков происходит перенаправление (роутинг) сообщения соотвествующему подписчику.

Получив решение на проверку, сервис проверки в соотвествии со своей логикой выносит вердикт.
Это может занять длительное время, однако как только вердикт вынесен, сообщение с вердиктом отправляется в другую очередь в рамках того же брокера сообщений (блок result queue рис. \ref{fig:design}).
У этой очереди один подписчик - координатор. 
Он вычитывает вердикты из очереди и обновляет состояние посылки в базе данных.

Стоит отметить, что такая архитектура позволяет легко масштабировать количество сервисов проверки даже одного типа.
Вычитывание посылок из очереди может конкурентно осуществлять неограниченное количество сервисов. 
Также такая архитектура устойчива к падениям проверяюших сервисов засчет гарантий, которые предоставляют брокеры сообщений.
Посылка будет храниться в очереди до тех пор, пока вердикт по ней не будет отправлен координатору.

\pagebreak
\begin{figure}[h]
\hspace*{-2.0cm} \includegraphics[scale=0.48]{images/design.jpg}
\centering
\caption{Архитектура системы \label{fig:design}}
\end{figure}